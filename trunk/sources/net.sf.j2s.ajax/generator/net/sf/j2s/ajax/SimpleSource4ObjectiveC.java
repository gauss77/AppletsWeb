/*******************************************************************************
 * Copyright (c) 2012 java2script.org and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Zhou Renjian - initial API and implementation
 *******************************************************************************/

package net.sf.j2s.ajax;

import java.io.File;
import java.io.FileOutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import net.sf.j2s.ajax.SimpleSerializable;

public class SimpleSource4ObjectiveC {
	
	static String folder = "Project";
	static String author = "Author";
	static String company = "Company";
	static String constantPrefix = "C_";

	@SuppressWarnings("deprecation")
	public static String generateHeaderFile(SimpleSerializable s) {
		StringBuffer buffer = new StringBuffer();
		
		Class<?> clazz = s.getClass();
		String clazzName = clazz.getName();
		String simpleClazzName = clazzName;
		int idx = clazzName.lastIndexOf('.');
		if (idx != -1) {
			simpleClazzName = clazzName.substring(idx + 1);
		}
		Date date = new Date();
		buffer.append("//\r\n");
		buffer.append("//  ");
		buffer.append(simpleClazzName);
		buffer.append(".h\r\n");
		buffer.append("//  ");
		buffer.append(folder);
		buffer.append("\r\n");
		buffer.append("//\r\n");
//		buffer.append("//  Created by ");
//		buffer.append(author);
//		buffer.append(" on ");
//		buffer.append(date.getMonth() + 1);
//		buffer.append("/");
//		buffer.append(date.getDate());
//		buffer.append("/");
//		buffer.append(date.getYear() % 100);
//		buffer.append(".\r\n");
		buffer.append("//  Generated by Java2Script.\r\n");
		buffer.append("//  Copyright (c) ");
		buffer.append(date.getYear() + 1900);
		buffer.append(" ");
		buffer.append(company);
		buffer.append(". All rights reserved.\r\n");
		buffer.append("//\r\n");
		buffer.append("\r\n");
		
		Class<?> superClazz = s.getClass().getSuperclass();
		String superClazzName = superClazz.getName();
		String simpleSuperClazzName = superClazzName;
		idx = superClazzName.lastIndexOf('.');
		if (idx != -1) {
			simpleSuperClazzName = superClazzName.substring(idx + 1);
		}

//		if ("BaseRPCRunnable".equals(simpleSuperClazzName)) {
//			simpleSuperClazzName = "BaseRPC";
//		}
		
		buffer.append("#import \"");
		buffer.append(simpleSuperClazzName);
		buffer.append(".h\"\r\n");
		buffer.append("\r\n");

		boolean gotStaticFinalFields = false;
		Field[] clazzFields = clazz.getDeclaredFields();
		for (int i = 0; i < clazzFields.length; i++) {
			Field f = clazzFields[i];
			int modifiers = f.getModifiers();
			if ((modifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0
					&& (modifiers & Modifier.STATIC) != 0 && (modifiers & Modifier.FINAL) != 0) {
				buffer.append("#define ");
				if (constantPrefix != null && constantPrefix.length() > 0) {
					buffer.append(constantPrefix);
				}
				buffer.append(simpleClazzName.toUpperCase());
				buffer.append("_");
				buffer.append(f.getName());
				buffer.append(" ");
				Class<?> type = f.getType();
				if (type == int.class) {
					try {
						buffer.append("" + f.getInt(s.getClass()));
					} catch (Throwable e) {
						e.printStackTrace();
					}
				} else if (type == long.class) {
					try {
						buffer.append(f.getLong(s.getClass()) + "L");
					} catch (Throwable e) {
						e.printStackTrace();
					}
				} else if (type == short.class) {
					try {
						buffer.append("" + f.getShort(s.getClass()));
					} catch (Throwable e) {
						e.printStackTrace();
					}
				} else if (type == byte.class) {
					try {
						buffer.append("" + f.getByte(s.getClass()));
					} catch (Throwable e) {
						e.printStackTrace();
					}
				} else if (type == char.class) {
					try {
						buffer.append("\'" + f.getChar(s.getClass()) + "\'");
					} catch (Throwable e) {
						e.printStackTrace();
					}
				} else if (type == float.class) {
					try {
						buffer.append("" + f.getFloat(s.getClass()));
					} catch (Throwable e) {
						e.printStackTrace();
					}
				} else if (type == double.class) {
					try {
						buffer.append("" + f.getDouble(s.getClass()));
					} catch (Throwable e) {
						e.printStackTrace();
					}
				} else if (type == String.class) {
					try {
						buffer.append("\"" + f.get(s.getClass()) + "\"");
					} catch (Throwable e) {
						e.printStackTrace();
					}
				} else {
					System.out.println("Not supporting type " + type + " for field " + f.getName());
				}
				buffer.append("\r\n");
				gotStaticFinalFields = true;
			}
		}
		
		if (gotStaticFinalFields) {
			buffer.append("\r\n");
		}

		buffer.append("@interface ");
		buffer.append(simpleClazzName);
		buffer.append(" : ");
		buffer.append(simpleSuperClazzName);
		buffer.append(" {\r\n");
		buffer.append("\r\n");		
		
		Map<String, Field> fields = new HashMap<String, Field>();
		for (int i = 0; i < clazzFields.length; i++) {
			Field f = clazzFields[i];
			int modifiers = f.getModifiers();
			if ((modifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0
					&& (modifiers & (Modifier.TRANSIENT | Modifier.STATIC)) == 0) {
				fields.put(f.getName(), f);
			}
		}

		for (Iterator<Field> itr = fields.values().iterator(); itr.hasNext();) {
			Field field = (Field) itr.next();
			String name = field.getName();
			Class<?> type = field.getType();
			
			buffer.append("    ");
			if (type == int.class) {
				buffer.append("int ");
			} else if (type == long.class) {
				buffer.append("long long ");
			} else if (type == short.class) {
				buffer.append("short ");
			} else if (type == byte.class) {
				buffer.append("int ");
			} else if (type == char.class) {
				buffer.append("int ");
			} else if (type == double.class) {
				buffer.append("double ");
			} else if (type == float.class) {
				buffer.append("float ");
			} else if (type == boolean.class) {
				buffer.append("BOOL ");
			} else if (type == String.class) {
				buffer.append("NSString *");
			} else if (type == byte[].class) {
				if (s.bytesCompactMode()) {
					buffer.append("NSData *");
				} else {
					buffer.append("NSMutableArray *");
				}
			} else if (type == int[].class || type == long[].class || type == double[].class
					|| type == short[].class || type == char[].class
					|| type == float[].class || type == boolean[].class || type == String[].class) {
				buffer.append("NSMutableArray *");
			} else {
				System.out.println("Unsupported type " + type);
			}
			buffer.append(name);
			buffer.append(";\r\n");
		}
		
		buffer.append("\r\n");
		buffer.append("}\r\n");
		buffer.append("\r\n");

		for (Iterator<Field> itr = fields.values().iterator(); itr.hasNext();) {
			Field field = (Field) itr.next();
			String name = field.getName();
			Class<?> type = field.getType();
			
			buffer.append("@property (nonatomic");
			if (type == int.class) {
				buffer.append(") int ");
			} else if (type == long.class) {
				buffer.append(") long long ");
			} else if (type == short.class) {
				buffer.append(") short ");
			} else if (type == byte.class) {
				buffer.append(") int ");
			} else if (type == char.class) {
				buffer.append(") int ");
			} else if (type == double.class) {
				buffer.append(") double ");
			} else if (type == float.class) {
				buffer.append(") float ");
			} else if (type == boolean.class) {
				buffer.append(") BOOL ");
			} else if (type == String.class) {
				buffer.append(", retain) NSString *");
			} else if (type == byte[].class) {
				if (s.bytesCompactMode()) {
					buffer.append(", retain) NSData *");
				} else {
					buffer.append(", retain) NSMutableArray *");
				}
			} else if (type == int[].class || type == long[].class || type == double[].class
					|| type == short[].class || type == char[].class
					|| type == float[].class || type == boolean[].class || type == String[].class) {
				buffer.append(", retain) NSMutableArray *");
			} else {
				System.out.println("Unsupported type " + type);
			}
			buffer.append(name);
			buffer.append(";\r\n");
		}

		buffer.append("\r\n");
		buffer.append("- (NSString *) className;\r\n");
		buffer.append("- (NSMutableArray *) fields;\r\n");
		buffer.append("\r\n");
		buffer.append("@end\r\n");

		return buffer.toString();
	}
	
	@SuppressWarnings("deprecation")
	public static String generateImplementationFile(SimpleSerializable s) {
		StringBuffer buffer = new StringBuffer();
		
		Class<?> clazz = s.getClass();
		String clazzName = clazz.getName();
		String simpleClazzName = clazzName;
		int idx = clazzName.lastIndexOf('.');
		if (idx != -1) {
			simpleClazzName = clazzName.substring(idx + 1);
		}
		Date date = new Date();
		buffer.append("//\r\n");
		buffer.append("//  ");
		buffer.append(simpleClazzName);
		buffer.append(".m\r\n");
		buffer.append("//  ");
		buffer.append(folder);
		buffer.append("\r\n");
		buffer.append("//\r\n");
//		buffer.append("//  Created by ");
//		buffer.append(author);
//		buffer.append(" on ");
//		buffer.append(date.getMonth() + 1);
//		buffer.append("/");
//		buffer.append(date.getDate());
//		buffer.append("/");
//		buffer.append(date.getYear() % 100);
//		buffer.append(".\r\n");
		buffer.append("//  Generated by Java2Script.\r\n");
		buffer.append("//  Copyright (c) ");
		buffer.append(date.getYear() + 1900);
		buffer.append(" ");
		buffer.append(company);
		buffer.append(". All rights reserved.\r\n");
		buffer.append("//\r\n");
		buffer.append("\r\n");

		buffer.append("#import \"");
		buffer.append(simpleClazzName);
		buffer.append(".h\"\r\n");
		buffer.append("\r\n");
		
		buffer.append("@implementation ");
		buffer.append(simpleClazzName);
		buffer.append("\r\n");
		buffer.append("\r\n");		

		Set<String> j2sIgnoredFileds = new HashSet<String>();
		
		Map<String, Field> fields = new HashMap<String, Field>();
		Field[] clazzFields = clazz.getDeclaredFields();
		for (int i = 0; i < clazzFields.length; i++) {
			Field f = clazzFields[i];
			int modifiers = f.getModifiers();
			if ((modifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0
					&& (modifiers & (Modifier.TRANSIENT | Modifier.STATIC)) == 0) {
				fields.put(f.getName(), f);
				if ((modifiers & Modifier.PROTECTED) != 0) {
					j2sIgnoredFileds.add(f.getName());
				}
			}
		}

		boolean needDealloc = false;
		for (Iterator<Field> itr = fields.values().iterator(); itr.hasNext();) {
			Field field = (Field) itr.next();
			String name = field.getName();
			Class<?> type = field.getType();
			
			if (type == String.class) {
				needDealloc = true;
			} else if (type == int[].class || type == long[].class || type == double[].class
					|| type == short[].class || type == byte[].class || type == char[].class
					|| type == float[].class || type == boolean[].class || type == String[].class) {
				needDealloc = true;
			}
			
			buffer.append("@synthesize ");
			buffer.append(name);
			buffer.append(";\r\n");
		}
		
		buffer.append("\r\n");
		buffer.append("- (NSString *) className {\r\n");
		buffer.append("    return @\"");
		buffer.append(clazzName);
		buffer.append("\";\r\n");
		buffer.append("}\r\n");
		buffer.append("\r\n");
		buffer.append("- (NSMutableArray *) fields {\r\n");
		buffer.append("    NSMutableArray *arr = [super fields];\r\n");
		for (Iterator<Field> itr = fields.values().iterator(); itr.hasNext();) {
			Field field = (Field) itr.next();
			String name = field.getName();
			if (j2sIgnoredFileds.contains(name)) {
				System.out.println("Ignoring ..." + name);
				continue;
			}
			Class<?> type = field.getType();
			
			buffer.append("    [arr addObject:[SimpleField makeField:@\"");
			buffer.append(name);
			buffer.append("\" withType:SimpleFieldType");
			if (type == int.class) {
				buffer.append("Int");
			} else if (type == long.class) {
				buffer.append("Long");
			} else if (type == short.class) {
				buffer.append("Short");
			} else if (type == byte.class) {
				buffer.append("Byte");
			} else if (type == char.class) {
				buffer.append("Char");
			} else if (type == double.class) {
				buffer.append("Double");
			} else if (type == float.class) {
				buffer.append("Float");
			} else if (type == boolean.class) {
				buffer.append("Boolean");
			} else if (type == String.class) {
				buffer.append("String");
			} else if (type == int[].class) {
				buffer.append("IntArray");
			} else if (type == long[].class) {
				buffer.append("LongArray");
			} else if (type == short[].class) {
				buffer.append("ShortArray");
			} else if (type == byte[].class) {
				if (s.bytesCompactMode()) {
					buffer.append("ByteData");
				} else {
					buffer.append("ByteArray");
				}
			} else if (type == char[].class) {
				buffer.append("CharArray");
			} else if (type == float[].class) {
				buffer.append("FloatArray");
			} else if (type == double[].class) {
				buffer.append("DoubleArray");
			} else if (type == boolean[].class) {
				buffer.append("BooleanArray");
			} else if (type == String[].class) {
				buffer.append("StringArray");
			} else {
				System.out.println("Unsupported type " + type);
			}
			buffer.append("]];\r\n");
		}
		buffer.append("    return arr;\r\n");
		buffer.append("}\r\n");
		buffer.append("\r\n");

		if (needDealloc) {
			buffer.append("- (void) dealloc {\r\n");
			for (Iterator<Field> itr = fields.values().iterator(); itr.hasNext();) {
				Field field = (Field) itr.next();
				String name = field.getName();
				Class<?> type = field.getType();
				
				if (type == String.class | type == int[].class || type == long[].class || type == double[].class
						|| type == short[].class || type == byte[].class || type == char[].class
						|| type == float[].class || type == boolean[].class || type == String[].class) {
					buffer.append("    self.");
					buffer.append(name);
					buffer.append(" = nil;\r\n");
				}
			}
			buffer.append("    [super dealloc];\r\n");
			buffer.append("}\r\n");
			buffer.append("\r\n");
		}

		buffer.append("@end\r\n");

		return buffer.toString();
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		if (args == null || args.length < 2 + 3) {
			System.out.println("Usage: " + SimpleSource4ObjectiveC.class.getName() + " <sources folder> <author> <orgization or company> <constant prefix> <class> [class ...]");
			return;
		}
		String targetFolder = args[0];
		File f = new File(targetFolder);
		if (f.exists()) {
			if (!f.isDirectory()) {
				System.out.println("Target folder " + f.getAbsolutePath() + " is not a folder.");
				return;
			}
		} else {
			boolean ok = f.mkdirs();
			if (!ok) {
				System.out.println("Failed to create target folder " + f.getAbsolutePath() + ".");
				return;
			}
		}
		folder = f.getName();
		author = args[1];
		company = args[2];
		constantPrefix = args[3];
		for (int i = 1 + 3; i < args.length; i++) {
			String j2sSimpleClazz = args[i];
			try {
				Class<?> clazz = Class.forName(j2sSimpleClazz);
				Object inst = clazz.newInstance();
				if (inst instanceof SimpleSerializable) {
					SimpleSerializable s = (SimpleSerializable) inst;
					
					String simpleName = j2sSimpleClazz;
					int idx = j2sSimpleClazz.lastIndexOf('.');
					if (idx != -1) {
						simpleName = j2sSimpleClazz.substring(idx + 1);
					}
					String h = generateHeaderFile(s);
					FileOutputStream fos = null;
					try {
						fos = new FileOutputStream(new File(targetFolder, simpleName + ".h"));
						fos.write(h.getBytes());
					} catch (Exception e) {
						e.printStackTrace();
					} finally {
						if (fos != null) {
							try {
								fos.close();
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
					System.out.println(new File(targetFolder, simpleName + ".h").getAbsolutePath());
					String m = generateImplementationFile(s);
					fos = null;
					try {
						fos = new FileOutputStream(new File(targetFolder, simpleName + ".m"));
						fos.write(m.getBytes());
					} catch (Exception e) {
						e.printStackTrace();
					} finally {
						if (fos != null) {
							try {
								fos.close();
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
					System.out.println(new File(targetFolder, simpleName + ".m").getAbsolutePath());
				}
			} catch (Throwable e) {
				e.printStackTrace();
			}

		}
	}

}
