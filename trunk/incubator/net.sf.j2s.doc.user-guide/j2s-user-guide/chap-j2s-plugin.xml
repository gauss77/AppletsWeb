  <!--
    Copyright (C) 2010 SebastiÃ¡n Gurin. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free
    Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover
    Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled "GNU Free Documentation License". @author: sgurin
  -->

<chapter  id="chap-j2s-plugin">

  <title>The J2S plugin</title>

  <epigraph>
    <attribution>Albert Einstein </attribution>
    <para>
      Everything that can be counted does not necessarily count; everything that counts cannot necessarily be counted.
  </para>
  </epigraph>




<para>TODO: about the plugin:</para>
<programlisting>
8. Support creating Java2Script projects by wizard, including
Servlet project
9. Support Eclipse versions from 3.3 to 3.6     
</programlisting>

  <section id="chap-j2s-plugin-sec-project">
    <title>Java2Script project</title>

    <para>this section describe project configuration, project properties page, .j2s file,  in .j2s file</para>
    <para>TODO</para>

  </section>




  <section id="chap-j2s-plugin-sec-compiler">
  <title>J2S Java to JavaScript compiler</title>
  
    <para>The most important component is the java to javascript code translator. This is an eclipse plugin, 
  based on eclipse java develpment tools (JDT / http://www.eclipse.org/jdt/), that will compile your eclipse 
  java project to javascript. </para>
  
        <programlisting>
1. Object oriented JavaScript simulator is introduced
2. JavaScript ClassLoader is built inside
3. Eclipse JDT based Java to JavaScript compiler, support Java
1.4 and Java 5 features, including generic, enums, static imports,
enhanced loops
4. Support incremental building for Java projects
5. Support Hotspot JavaScript swapping for debugging
6. Support most classes in java.lang.*, java.utils.* and others
packages
7. Support native JavaScript through @j2s* Javadoc in Java sources and java anotations

      </programlisting>
      
  <para>TODO: do this better. Ideas: 
  * talk about compiler supported java versions, 
  * in section chap-java-to-js-translation will talk about code tranlation
  * 
  </para>  
  
  
    <section>
    <title>Compiler configuration</title>
    <para>TODO: how the compiler can be configure with the .j2s project's file </para>
    </section>
  
  </section>



  <section id="rer">
    <title>Application launching</title>

    <para>this section describe j2s app launcing in detail</para>

    <para>TODO</para>

    <section id="lk">
      <title>Using templates</title>

      <para>this section describe j2s application renderization throw templates, in this case doucments the velocity contribution.
    </para>
      <para>TODO</para>

    </section>
  </section>
  
  
  
  
  
  
  
  
  <section><title>Debugging</title>
  <para>how turn on debuggin?</para>
  <para>what happens when debug is on?</para>
  
  
  
  
  <section><title>JavaScript ClassLoader and Hotspot</title>  
<!--parts of this stolen from Zhou Renjian blog: http://inside.java2script.com/2007/05/30/javascript-classloader-and-hotspot.html-->

  <para>If you are familiar with Java debugging, you must know there is a technology called "Hotspot". One feature of Hotspot is to replace 
  old classes bytecodes with a new ones that are generated by dynamic compilers. This feature helps developers a lot in debugging. 
  That is to say, when a developer load a very complex application in debugging mode, he want to modify the sources a little, he can just 
  do it, the compiler will compile those related classes and notify classloader to load those affected classes bytecodes. So the changes are loaded in
  an application being executed without the need of reloading it.
  It saves lots of time by avoiding closing, reopening and waiting big applications again and again. This is very convenient when comparing to those 
  static compiled applications written by C or C++ languages.</para>
  
  <para>Let's try it with an example. The following java test, creates an html button with a click event handle. Each time the user clicks the button, 
  the instance method <code>doCLickAction()</code> is called. </para>
  
  <programlisting>
package org.sgx.j2s.js;

import org.sgx.j2s.html.HTMLUtils;

public class HotSpotTest1 {
  int counter = 0;  
  
  public static void main(String[] args) {
    new HotSpotTest1().test();
  }
  
  public void test() {
    
    //creates an html button element in document.body, with label "click me" and 
    //with an event handler that will call doCLickAction() instance method
    
    HTMLUtils.createButton(JsUtils.document().body, "click me", new Runnable() {
      public void run() {
        counter++;
        doClickAction();
      }
    });   
  }

  protected void doClickAction() {
    System.out.println(counter+" say hello!");
  }

}
</programlisting>

<para>Now we will use J2S Hot Spot for debugging the application making changes to sources that will be reflected in the html document 
without having to reload the application. For debugging a J2S application with HotSpot, we use Debug As... instead of Run As... in the context menu:</para>

<figure>
  <title>Debug As... Java2Script application context menu</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="images/j2s-debug-as.png"></imagedata>
    </imageobject>
  </mediaobject>
</figure> 
    
<para>This will execute our application that will show a button labeled "click me". If we click the button once a message is printed: </para>

<figure>
  <title>HotSpot debugging the application - first screenshot</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="images/hotspot-app-1.png"></imagedata>
    </imageobject>
  </mediaobject>
</figure> 

<para>Now the interesting part. Change the message printed in the method <code>doClickAction()</code>, for example:</para>

<programlisting>
protected void doClickAction() {
  System.out.println(counter+" say hello CRUEL WORLD!");
}
</programlisting>

<para>Save the changes and keep looking at your application at the J2S console. 
After a few seconds, you should see a red label "Application loaded":
</para>

<figure>
  <title>HotSpot debugging the application - application change notification</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="images/hotspot-app-2.png"></imagedata>
    </imageobject>
  </mediaobject>
</figure> 

<para>That means the J2S HotSpot mechanish has detected changes in classes of current application, 
and the application has loaded the new changes. So, we can click the button again, and will see
the new message printed:
</para>

<figure>
  <title>HotSpot debugging the application - changes were applied</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="images/hotspot-app-3.png"></imagedata>
    </imageobject>
  </mediaobject>
</figure> 

<para>W just were able of modify the application and reflect those changes all without restarting 
our application, or in other words, we have just make a "hot change" in our application. </para>

<note><para>Just like in java, only changes to instance variable and instance methods will be 
supported by HotSpot. Changes to static methods, or changes in class signatures 
(like adding/removing/renaming) methods are not supported by HotSpot.</para></note>


  <bridgehead id="asd" renderas="sect2">
    How is this accomplished?
  </bridgehead>
  
  <para>
  Java2Script also implements JavaScript's Hotspot technology. It is not complicate, because JavaScript is 
  already a very robust and convenient language to do so. All Java2Script implementation is to clean those classes' declaration inside JavaScript 
  class inheritance system simulator. And then reload the *.js using Java2Script's classloader. In the implementation, classloader does not change 
  class or object's prototype when a reloaded class is redefined, it's possible to keep all classes relationships without breaking those already 
  instantiated instances.
  </para> 
  
  <para><indexterm>
   <primary>J2SIHS</primary>
</indexterm>
<indexterm>
   <primary>Java2Script Inner Hotspot Server</primary>
</indexterm>
  To trigger Java2Script class simulator to Hotspot swapping, there is a thread at the plugin side, trying to load an 
  updating JavaScript classes list from Java2Script compiler in Eclipse. Its work is simple, just 
  trying to load http://127.0.0.1:1725/&lt;session>.js. And the server listening on default port 
  1725 is started by Java2Script compiler, called "Java2Script Inner Hotspot Server (J2SIHS)". 
  When a compiling occurs, compiler will notify this server that a class is updated, and the server 
  will add the information to the list. Once a JavaScript request arrives, it will send out the list 
  according to the request session id. And when the JavaScript client thread gets the updated classes 
  list, it will try to unload related classes and reload them. That is the rough procedure of
   Java2Script Hotspot technology.
  </para>
  
  
  <para>By using Hotspot, I think it is much more convenient for me to develop JavaScript RIA in Java codes than 
before, especially in developing SWT applications.  </para>  
  </section>
  
  </section>





  <section><title>Libraries in Java2Script</title>
  <para>
  In this section we will detail mechanisms provided by Java2Script plugin for using and distributing java software. 
  How java software components can be distributed so other Java2Script users can use them in their J2S porojects.
   </para>
   
   <para>Suppose you develop a very useful software component in Java2Script and now you want to distribute so other can use it in their own java2script projects. 
   In normal java project we normally put our .class files inside a .jar (Java ARchive) file, and distribute the .jar. That is enought, but not in a 
   java2script project where, besides .class files you must also can distribute generated javascript files.</para>
   
   <para>Of course you can always distribute your library sources, and let the users import the osources into their own projects, perhaps in differents sourcefolders, 
   but that is generally a good idea when you want to encapsulate your library api and implementation.</para>
   
   <para>Fortunately, Java2Script provide with flexible mechanism of library definition. Also as we will see, Java2Script support for defining 
   how the library must loaded</para>
   <para>TODO: talk about j2slib and how swt, junit etc are inside. TODO: talk about .j2x files and package.js files that le definehow alibrary must be loaded.
   Also, try and if works to dev a library, put it in other folder that j2slib, with a pacakge.js and lib.j2z file, and show how oackage.js is evaluated, and how to use it for loading one, concatenating several files, etcx</para>
   
   <para>TODO: p/d: future extension packer can be mention here for intelligent generattion of big .js file .</para>
   
  </section>



  <section><title>Command line API</title><para>TODO: document here the expiremental support for j2s console api. ?</para></section>
  
  
</chapter>
